// src/components/ChatMessage.jsx
import React, { useState, useEffect, useRef } from 'react';
import { UserCircleIcon, CpuChipIcon, ClipboardDocumentIcon, CheckCircleIcon } from '@heroicons/react/24/solid';
import { CheckIcon } from '@heroicons/react/24/outline';
import ReactMarkdown from 'react-markdown';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { nightOwl } from 'react-syntax-highlighter/dist/esm/styles/prism';

import remarkGfm from 'remark-gfm';
import remarkBreaks from 'remark-breaks';
import rehypeRaw from 'rehype-raw';
// T·∫°o schema ri√™ng cho rehypeSanitize ƒë·ªÉ cho ph√©p c√°c th·∫ª c·∫ßn thi·∫øt
import { defaultSchema } from 'hast-util-sanitize';
import rehypeSanitize from 'rehype-sanitize';
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypeExternalLinks from 'rehype-external-links';
// Add emoji support
import emoji from 'remark-emoji';

import useTypingEffect from '../hooks/useTypingEffect';

import '../assets/css/markdown-styles.css';
import {useChat} from '../contexts/ChatContext';

function ChatMessage({ message, isLoading = false, isLast = false, typingEffectEnabled = true }) {
  // Check if message is from user
  const isUser = message.role === 'USER' || message.role === 'user';
  const [displayedContent, setDisplayedContent] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const typingRef = useRef(null);
  const [typeIndex, setTypeIndex] = useState(0);
  const [copiedCodeBlock, setCopiedCodeBlock] = useState(null);
  
  // T·∫°o schema cho rehypeSanitize ƒë·ªÉ cho ph√©p t·∫•t c·∫£ c√°c th·∫ª HTML c·∫ßn thi·∫øt
  const schema = structuredClone(defaultSchema);
  schema.tagNames.push('strong', 'b', 'i', 'em', 'strike', 'del', 'code', 'pre');
  schema.attributes['*'] = ['className', 'style'];  // Cho ph√©p class v√† style tr√™n m·ªçi th·∫ª
  
  // Function to properly decode Unicode characters and fix markdown 
  const decodeAndFixMarkdown = (content) => {
    if (!content) return '';
    
    // Console log ƒë·ªÉ debug
    console.log("Original content:", content);
    
    // Decode Unicode characters (like emojis)
    let decoded = content.replace(/\\u[\dA-F]{4,6}/gi, (match) => {
      try {
        const codeStr = match.replace(/\\u[\{\}]*/g, '');
        return String.fromCharCode(parseInt(codeStr, 16));
      } catch(e) {
        return match;
      }
    });
    
    // X·ª≠ l√Ω surrogate pairs cho emoji
    decoded = decoded.replace(/\\u([\dA-F]{4})\\u([\dA-F]{4})/gi, (match, highSurr, lowSurr) => {
      try {
        const high = parseInt(highSurr, 16);
        const low = parseInt(lowSurr, 16);
        if (high >= 0xD800 && high <= 0xDBFF && low >= 0xDC00 && low <= 0xDFFF) {
          return String.fromCharCode(high, low);
        }
        return match;
      } catch(e) {
        return match;
      }
    });

    // X·ª≠ l√Ω basic emoji
    decoded = decoded.replace(/:([\w+-]+):/g, (match, emojiName) => {
      const emojiMap = {
        'smile': 'üòä', 'grinning': 'üòÄ', 'thumbsup': 'üëç',
        'heart': '‚ù§Ô∏è', 'check': '‚úÖ', 'x': '‚ùå'
      };
      return emojiMap[emojiName] || match;
    });
    
    // ===== GI·∫¢I PH√ÅP M·ªöI CHO MARKDOWN =====
    
    // 1. Chu·∫©n b·ªã text ƒë·ªÉ x·ª≠ l√Ω d·ªÖ d√†ng h∆°n
    let lines = decoded.split('\n');
    
    // 2. X·ª≠ l√Ω t·ª´ng d√≤ng
    for (let i = 0; i < lines.length; i++) {
      // X·ª≠ l√Ω ƒë·ªãnh d·∫°ng in ƒë·∫≠m (**text**)
      // Thay th·∫ø ** text ** th√†nh <strong>text</strong>
      lines[i] = lines[i].replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // X·ª≠ l√Ω italic (*text*)
      lines[i] = lines[i].replace(/\*([^*]+)\*/g, '<em>$1</em>');
      
      // ƒê·∫£m b·∫£o c√°c th·∫ª HTML ƒë√£ ƒë∆∞·ª£c th√™m v√†o c√≥ kho·∫£ng tr·∫Øng ƒë√∫ng
      lines[i] = lines[i].replace(/<(\/?[a-z]+)>/g, ' <$1> ').replace(/\s+/g, ' ').trim();
    }
    
    // 3. X·ª≠ l√Ω danh s√°ch
    for (let i = 0; i < lines.length; i++) {
      // X·ª≠ l√Ω danh s√°ch bullet
      if (/^\s*\*\s/.test(lines[i])) {
        lines[i] = lines[i].replace(/^\s*\*\s/, '- ');
      }
      
      // ƒê·∫£m b·∫£o danh s√°ch ƒë∆∞·ª£c ƒë·∫∑t ƒë√∫ng c√°ch
      if (i > 0 && lines[i].trimStart().startsWith('-') && !lines[i-1].trimStart().startsWith('-')) {
        lines.splice(i, 0, '');  // Th√™m d√≤ng tr·ªëng tr∆∞·ªõc danh s√°ch
        i++;
      }
      
      // ƒê·∫£m b·∫£o bullet point c√≥ kho·∫£ng tr·∫Øng ƒë·ªß
      if (lines[i].trimStart().startsWith('-')) {
        lines[i] = lines[i].replace(/^\s*-/, '- ');
      }
    }
    
    // 4. X·ª≠ l√Ω ƒë·ªÅ m·ª•c (#)
    for (let i = 0; i < lines.length; i++) {
      const headingMatch = lines[i].match(/^(#{1,6})\s*(.*)/);
      if (headingMatch) {
        const level = headingMatch[1].length;
        const text = headingMatch[2];
        
        // Th√™m d√≤ng tr·ªëng tr∆∞·ªõc v√† sau ƒë·ªÅ m·ª•c n·∫øu c·∫ßn
        if (i > 0 && lines[i-1].trim() !== '') {
          lines.splice(i, 0, '');
          i++;
        }
        
        // ƒê·ªãnh d·∫°ng l·∫°i ƒë·ªÅ m·ª•c
        lines[i] = `${'#'.repeat(level)} ${text}`;
        
        // Th√™m d√≤ng tr·ªëng sau ƒë·ªÅ m·ª•c
        if (i < lines.length - 1 && lines[i+1].trim() !== '') {
          lines.splice(i+1, 0, '');
        }
      }
    }
    
    // 5. X·ª≠ l√Ω code blocks
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trimStart().startsWith('```')) {
        // Th√™m d√≤ng tr·ªëng tr∆∞·ªõc code block n·∫øu c·∫ßn
        if (i > 0 && lines[i-1].trim() !== '') {
          lines.splice(i, 0, '');
          i++;
        }
      }
    }
    
    // 6. K·∫øt h·ª£p l·∫°i th√†nh vƒÉn b·∫£n markdown chu·∫©n
    decoded = lines.join('\n');
    
    // 7. Th√™m m·ªôt s·ªë x·ª≠ l√Ω cu·ªëi c√πng
    
    // ƒê·∫£m b·∫£o ƒë·ªãnh d·∫°ng in ƒë·∫≠m (n·∫øu c√≤n s√≥t)
    decoded = decoded.replace(/\*\*([^*<>]+)\*\*/g, '<strong>$1</strong>');
    
    // Th√™m kho·∫£ng tr·ªëng sau c√°c d·∫•u markdown ƒë·ªÉ ƒë·∫£m b·∫£o ch√∫ng ƒë∆∞·ª£c nh·∫≠n d·∫°ng
    decoded = decoded.replace(/([*_~])([^ *_~])/g, '$1 $2');
    
    // X·ª≠ l√Ω c√°c d·∫•u ** ƒë√£ ƒë∆∞·ª£c escaped
    decoded = decoded.replace(/\\\*/g, '*');
    
    // Debug output
    console.log("Processed content:", decoded);
    
    return decoded;
  };
  
  // Use loading dots hook
  const loadingDots = useTypingEffect(isLoading && isLast && !isUser);
  
  // Typing effect for AI messages
  useEffect(() => {
    // Process content to properly handle markdown
    const processedContent = isUser ? message.content : decodeAndFixMarkdown(message.content);
    
    // If user message or typing effect disabled, display full content immediately
    if (isUser || !typingEffectEnabled || !isLast || !processedContent) {
      setDisplayedContent(processedContent || '');
      setIsTyping(false);
      setTypeIndex(processedContent ? processedContent.length : 0);
      return;
    }

    // If loading, display partial content
    if (isLoading) {
      setDisplayedContent((processedContent || '') + loadingDots);
      setIsTyping(false);
      return;
    }

    // Initialize typing effect from beginning
    setDisplayedContent('');
    setTypeIndex(0);
    setIsTyping(true);

    // Typing effect with dynamic speed based on content length
    const typingSpeed = Math.max(10, Math.min(50, 30 - processedContent.length / 100));

    const typingInterval = setInterval(() => {
      setTypeIndex(prevIndex => {
        if (prevIndex >= processedContent.length) {
          clearInterval(typingInterval);
          setIsTyping(false);
          return prevIndex;
        }
        
        // Get current character and update display
        const nextIndex = prevIndex + 1;
        setDisplayedContent(processedContent.substring(0, nextIndex));
        return nextIndex;
      });
    }, typingSpeed);

    return () => clearInterval(typingInterval);
  }, [message.content, isUser, isLast, isLoading, typingEffectEnabled, loadingDots]);

  // Format time
  const formatTime = (isoString) => {
    if (!isoString) return '';
    try {
        const date = new Date(isoString);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (error) {
        return '';
    }
  };

  // Handle code copy
  const handleCopyCode = (code) => {
    navigator.clipboard.writeText(code).then(() => {
      setCopiedCodeBlock(code);
      setTimeout(() => setCopiedCodeBlock(null), 2000); // Reset after 2 seconds
    });
  };

  // Custom components for React-Markdown with comprehensive support
  const components = {
    // Code blocks with syntax highlighting and copy button
    code({ node, inline, className, children, ...props }) {
      const match = /language-(\w+)/.exec(className || '');
      const language = match ? match[1] : '';
      const codeString = String(children).replace(/\n$/, '');
      
      return !inline ? (
        <div className="relative my-4 rounded-md overflow-hidden">
          <div className="flex items-center justify-between bg-gray-800 px-4 py-1 text-xs text-gray-200">
            <span>{language || 'code'}</span>
            <button
              className="bg-gray-700 hover:bg-gray-600 p-1 rounded text-white transition-colors ml-2"
              onClick={() => handleCopyCode(codeString)}
              title="Copy code"
            >
              {copiedCodeBlock === codeString ? 
                <CheckCircleIcon className="h-4 w-4 text-green-400" /> : 
                <ClipboardDocumentIcon className="h-4 w-4" />
              }
            </button>
          </div>
          <SyntaxHighlighter
            style={nightOwl}
            language={language || 'text'}
            PreTag="div"
            className="text-sm"
            showLineNumbers={codeString.split('\n').length > 3}
            wrapLines={true}
            {...props}
          >
            {codeString}
          </SyntaxHighlighter>
        </div>
      ) : (
        <code className="bg-gray-100 px-1.5 py-0.5 rounded text-red-600 font-mono text-sm" {...props}>
          {children}
        </code>
      );
    },
    
    // Paragraph component with proper spacing
    p: ({ children }) => (
      <p className="my-2 leading-relaxed">{children}</p>
    ),
    
    // Lists with proper formatting
    ul: ({ children, ordered, ...props }) => (
      <ul className="list-disc pl-6 my-3 space-y-1" {...props}>{children}</ul>
    ),
    
    ol: ({ children, ordered, ...props }) => (
      <ol className="list-decimal pl-6 my-3 space-y-1" {...props}>{children}</ol>
    ),
    
    li: ({ children, ...props }) => (
      <li className="mb-1" {...props}>{children}</li>
    ),
    
    // Headings with proper styling and anchor links
    h1: ({ children, id }) => (
      <h1 id={id} className="text-2xl font-bold mt-6 mb-4 border-b border-gray-200 pb-2">
        {children}
      </h1>
    ),
    h2: ({ children, id }) => (
      <h2 id={id} className="text-xl font-bold mt-5 mb-3 border-b border-gray-200 pb-1">
        {children}
      </h2>
    ),
    h3: ({ children, id }) => (
      <h3 id={id} className="text-lg font-bold mt-4 mb-2">
        {children}
      </h3>
    ),
    h4: ({ children, id }) => (
      <h4 id={id} className="text-base font-bold mt-3 mb-2">
        {children}
      </h4>
    ),
    
    // Line break
    br: () => <br className="block my-2" />,
    
    // Tables with responsive styling
    table: ({ children }) => (
      <div className="overflow-x-auto my-6 rounded-md shadow">
        <table className="min-w-full border border-gray-300 rounded-md">
          {children}
        </table>
      </div>
    ),
    thead: ({ children }) => (
      <thead className="bg-gray-100 border-b border-gray-300">
        {children}
      </thead>
    ),
    tbody: ({ children }) => (
      <tbody className="divide-y divide-gray-200">
        {children}
      </tbody>
    ),
    tr: ({ children }) => (
      <tr className="border-b border-gray-200 hover:bg-gray-50 transition-colors">
        {children}
      </tr>
    ),
    th: ({ children, align }) => {
      const alignClass = align === 'center' ? 'text-center' : align === 'right' ? 'text-right' : 'text-left';
      return <th className={`px-4 py-3 text-xs font-medium text-gray-700 uppercase tracking-wider border-r last:border-r-0 bg-gray-100 ${alignClass}`}>{children}</th>;
    },
    td: ({ children, align }) => {
      const alignClass = align === 'center' ? 'text-center' : align === 'right' ? 'text-right' : 'text-left';
      return <td className={`px-4 py-3 text-sm border-r last:border-r-0 ${alignClass}`}>{children}</td>;
    },
    
    // Text formatting
    // ƒê·∫£m b·∫£o strong ƒë∆∞·ª£c render ƒë√∫ng
    strong: ({ children }) => (
      <strong className="font-bold text-black dark:text-white bg-yellow-50 dark:bg-yellow-900 px-0.5 rounded">{children}</strong>
    ),
    
    // C·∫£i thi·ªán hi·ªÉn th·ªã in nghi√™ng
    em: ({ children }) => (
      <em className="italic text-gray-700 dark:text-gray-300">{children}</em>
    ),
    
    // Links with external indicator
    a: ({ href, title, children }) => (
      <a 
        href={href} 
        title={title} 
        target="_blank" 
        rel="noopener noreferrer"
        className="text-blue-600 hover:text-blue-800 hover:underline transition-colors inline-flex items-center"
      >
        {children}
        {href && href.startsWith('http') && (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
          </svg>
        )}
      </a>
    ),
    
    // Blockquote with styling
    blockquote: ({ children }) => (
      <blockquote className="border-l-4 border-blue-400 pl-4 py-2 italic text-gray-700 my-4 bg-blue-50 rounded-r-md">
        {children}
      </blockquote>
    ),
    
    // Images with responsive styling
    img: ({ src, alt }) => (
      <img 
        src={src} 
        alt={alt || ''} 
        className="max-w-full h-auto my-4 rounded-md shadow-sm" 
        loading="lazy"
      />
    ),
    
    // Task list items (checkboxes)
    input: ({ type, checked }) => {
      if (type === 'checkbox') {
        return (
          <input
            type="checkbox"
            checked={checked || false}
            readOnly
            className="mr-1 rounded"
          />
        );
      }
      return <input type={type} readOnly />;
    },
    
    // Horizontal rule
    hr: () => (
      <hr className="my-6 border-t border-gray-300" />
    )
  };

  // T√πy ch·ªânh c·∫•u h√¨nh rehypeSanitize
  const sanitizeSchema = {
    ...schema,
    attributes: {
      ...schema.attributes,
      code: [...(schema.attributes.code || []), 'className']
    }
  };

  // Th√™m class ph√π h·ª£p v·ªõi c·∫£ markdown-rendered v√† markdown-content
  const getMarkdownClasses = () => {
    return isUser 
      ? "prose prose-sm max-w-none markdown-content markdown-rendered text-white leading-normal" 
      : "prose prose-sm max-w-none markdown-content markdown-rendered leading-normal";
  };

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-6`}>
      <div className={`flex ${isUser ? 'flex-row-reverse' : 'flex-row'} items-start max-w-xs md:max-w-2xl lg:max-w-3xl w-full`}>
        {/* Avatar */}
        <div className={`flex-shrink-0 h-12 w-12 rounded-full flex items-center justify-center text-white shadow-md ${
          isUser ? 'bg-gradient-to-r from-indigo-500 to-purple-600 ml-2' : 'bg-gradient-to-r from-teal-500 to-cyan-600 mr-2'
        }`}>
          {isUser ? <UserCircleIcon className="h-8 w-8" /> : <CpuChipIcon className="h-8 w-8" />}
        </div>
        
        {/* Chat bubble container */}
        <div className={`relative px-6 py-4 rounded-2xl ${
          isUser 
            ? 'bg-gradient-to-br from-indigo-500 to-indigo-600 text-white rounded-tr-none shadow-lg' 
            : 'bg-white border border-gray-200 text-gray-800 rounded-tl-none shadow-md'
        } transition-shadow duration-200 hover:shadow-xl`}>
          {isUser ? (
            // User message content - plain text without Markdown formatting
            <div className="text-base whitespace-pre-wrap break-words text-white">
              {message.content}
            </div>
          ) : (
            // Assistant message content with Markdown styling
            <div className="text-base">
              {/* Loading/typing indicator */}
              {isLoading && isLast && (
                <div className="text-gray-500 text-sm mb-2 flex items-center">
                  <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse mr-2"></span>
                  <span>ƒêang tr·∫£ l·ªùi{loadingDots}</span>
                </div>
              )}
              {isTyping && (
                <div className="text-gray-500 text-sm mb-2 flex items-center">
                  <span className="w-2 h-2 rounded-full bg-blue-500 animate-pulse mr-2"></span>
                  <span>ƒêang g√µ...</span>
                </div>
              )}
              
              {/* ReactMarkdown v·ªõi class ƒë∆∞·ª£c s·ª≠a ƒë·ªÉ tr√°nh xung ƒë·ªôt */}
              <article className={getMarkdownClasses()}>
                <ReactMarkdown 
                  children={displayedContent}
                  components={components}
                  remarkPlugins={[
                    remarkGfm, 
                    remarkBreaks,
                    emoji // Add emoji support
                  ]}
                  rehypePlugins={[
                    rehypeRaw, 
                    [rehypeSanitize, sanitizeSchema], // S·ª≠ d·ª•ng schema t√πy ch·ªânh
                    rehypeSlug,
                    [rehypeAutolinkHeadings, { behavior: 'wrap' }],
                    [rehypeExternalLinks, { target: '_blank', rel: ['nofollow', 'noopener', 'noreferrer'] }]
                  ]}
                />
                
                {/* Typing cursor */}
                {isTyping && (
                  <span className="inline-block w-2 h-5 bg-blue-500 ml-0.5 animate-cursor-blink"></span>
                )}
              </article>
            </div>
          )}
          
          {/* Timestamp */}
          <div className={`text-sm mt-2 ${isUser ? 'text-indigo-200' : 'text-gray-400'} flex justify-end`}>
            {formatTime(message.createdAt)}
          </div>
        </div>
      </div>
    </div>
  );
}

export default ChatMessage;
